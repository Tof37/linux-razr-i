#include "displays/smd_qhd_amoled_430_cmd.h"
#include "mdfld_mot_cmn.h"
#include "mdfld_panel_generic.h"
#include "mdfld_dsi_dbi.h"
#include "mdfld_dsi_dbi_dpu.h"
#include "mdfld_dsi_pkg_sender.h"

extern bool kexec_in_progress;
extern int boot_mode_is_factory(void);

static u8 etc_cond_cmd_1[] = { 0xf0, 0x5a, 0x5a};
static u8 etc_cond_cmd_2[] = { 0xf1, 0x5a, 0x5a};
static u8 etc_cond_cmd_3[] = { 0xfc, 0x5a, 0x5a};
static u8 panel_cond_set[] = { 0xF8, 0x27, 0x27, 0x08,
			       0x08, 0x4E, 0xAA, 0x5E,
			       0x8A, 0x10, 0x3F, 0x10,
			       0x10, 0x00};
static u8 etc_cond2_cmd_1[] = { 0xF6, 0x00, 0x84, 0x09};

static u8 etc_cond2_cmd_2[]   = { 0xB0, 0x09};
static u8 etc_cond2_cmd_3[]   = { 0xD5, 0x64};
static u8 etc_cond2_cmd_4[]   = { 0xb0, 0x0b};
static u8 etc_cond2_cmd_5[]   = { 0xd5, 0xa4, 0x7e, 0x20};
static u8 etc_cond2_cmd_6[]   = { 0xb0, 0x08};
static u8 etc_cond2_cmd_7[]   = { 0xfd, 0xf8};
static u8 etc_cond2_cmd_8[]   = { 0xb0, 0x04};
static u8 etc_cond2_cmd_9[]   = { 0xf2, 0x4d};
static u8 etc_cond2_cmd_10[]  = { 0xb0, 0x05};
static u8 etc_cond2_cmd_11[]  = { 0xfd, 0x1f};
static u8 etc_cond2_cmd_12[]  = { 0xB1, 0x01, 0x00, 0x16};
static u8 exit_sleep_mode_cmd[] = { exit_sleep_mode};
static u8 mem_win2_cmd_1[] = { set_tear_on, 0x00};
static u8 mem_win2_cmd_2[] = { 0x2a, 0x00, 0x1e, 0x02,
				0x39};
static u8 mem_win2_cmd_3[] = { 0x2b, 0x00, 0x00, 0x03,
				0xbf};
static u8 mem_win2_cmd_4[] = {0xd1, 0x8a};
static u8 acl_cmd[] = { 0xc1, 0x47, 0x53, 0x13,
			0x53, 0x00, 0x00, 0x01,
			0xdf, 0x00, 0x00, 0x03,
			0x1f, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x01, 0x02,
			0x03, 0x07, 0x0e, 0x14,
			0x1c, 0x24, 0x2d, 0x2d,
			0x00};

static struct dsi_cmd_entry init_seq_1[] = {
	{CMD_MCS_LONG, sizeof(etc_cond_cmd_1), etc_cond_cmd_1},
	{CMD_MCS_LONG, sizeof(etc_cond_cmd_2), etc_cond_cmd_2},
	{CMD_MCS_LONG, sizeof(etc_cond_cmd_3), etc_cond_cmd_3}
};

static struct dsi_cmd_entry init_seq_2[] = {
	{CMD_MCS_LONG, sizeof(panel_cond_set), panel_cond_set},
	{CMD_MCS_LONG, sizeof(etc_cond2_cmd_1), etc_cond2_cmd_1},
	{CMD_MCS_SHORT1, sizeof(etc_cond2_cmd_2), etc_cond2_cmd_2},
	{CMD_MCS_SHORT1, sizeof(etc_cond2_cmd_3), etc_cond2_cmd_3},
	{CMD_MCS_SHORT1, sizeof(etc_cond2_cmd_4), etc_cond2_cmd_4},
	{CMD_MCS_LONG, sizeof(etc_cond2_cmd_5), etc_cond2_cmd_5},
	{CMD_MCS_SHORT1, sizeof(etc_cond2_cmd_6), etc_cond2_cmd_6},
	{CMD_MCS_SHORT1, sizeof(etc_cond2_cmd_7), etc_cond2_cmd_7},
	{CMD_MCS_SHORT1, sizeof(etc_cond2_cmd_8), etc_cond2_cmd_8},
	{CMD_MCS_SHORT1, sizeof(etc_cond2_cmd_9), etc_cond2_cmd_9},
	{CMD_MCS_SHORT1, sizeof(etc_cond2_cmd_10), etc_cond2_cmd_10},
	{CMD_MCS_SHORT1, sizeof(etc_cond2_cmd_11), etc_cond2_cmd_11},
	{CMD_MCS_LONG, sizeof(etc_cond2_cmd_12), etc_cond2_cmd_12},
};

static struct dsi_cmd_entry init_seq_3[] = {
	{CMD_MCS_SHORT0, sizeof(exit_sleep_mode_cmd), exit_sleep_mode_cmd},
	{CMD_SLEEP_MS, 120, NULL},
	{CMD_MCS_SHORT1, sizeof(mem_win2_cmd_1), mem_win2_cmd_1},
	{CMD_MCS_LONG,   sizeof(mem_win2_cmd_2), mem_win2_cmd_2},
	{CMD_MCS_LONG,   sizeof(mem_win2_cmd_3), mem_win2_cmd_3},
	{CMD_MCS_SHORT1, sizeof(mem_win2_cmd_4), mem_win2_cmd_4},
	{CMD_MCS_LONG,   sizeof(acl_cmd), acl_cmd}
};

#define MAX_BL_STEPS (30)
#define GAMMA_SETTING_SIZE (26)

static char def_gamma_settings_nit[MAX_BL_STEPS][GAMMA_SETTING_SIZE] = {
	/* 10 */
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0x61, 0x5B, 0x4B, 0x80, 0x83,
	 0x8E, 0xBD, 0xC9, 0xC4, 0x96, 0xA6, 0x94, 0xC0, 0xCF, 0xBB,
	 0x00, 0x49, 0x00, 0x4C, 0x00, 0x5B},
	/* 20 */
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0x6B, 0x65, 0x55, 0xA3, 0xAB,
	 0xB2, 0xB6, 0xC8, 0xBE, 0x99, 0xA8, 0x91, 0xC0, 0xCC, 0xBB,
	 0x00, 0x5A, 0x00, 0x5D, 0x00, 0x6F},
	/* 30 */
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0x7E, 0x78, 0x68, 0xA3, 0xB5,
	 0xB5, 0xBA, 0xCA, 0xC1, 0x9D, 0xAB, 0x91, 0xBF, 0xC9, 0xBA,
	 0x00, 0x67, 0x00, 0x69, 0x00, 0x7E},
	/* 40 */
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0x93, 0x8D, 0x7D, 0xA1, 0xBA,
	 0xB4, 0xBF, 0xCD, 0xC6, 0x9F, 0xAB, 0x90, 0xBE, 0xC9, 0xBC,
	 0x00, 0x70, 0x00, 0x70, 0x00, 0x87},
	/* 50 */
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0xA5, 0x9F, 0x8F, 0x9F, 0xBA,
	 0xB2, 0xBE, 0xCD, 0xC3, 0x9D, 0xA8, 0x8F, 0xBF, 0xCB, 0xBE,
	 0x00, 0x78, 0x00, 0x77, 0x00, 0x90},
	/* 60 */
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0x98, 0x96, 0x83, 0xA7, 0xBF,
	 0xBA, 0xBF, 0xCD, 0xC2, 0x9C, 0xA6, 0x8E, 0xBD, 0xCA, 0xBD,
	 0x00, 0x7F, 0x00, 0x7E, 0x00, 0x97},
	/* 70 */
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0xA8, 0xA8, 0x93, 0xA6, 0xBE,
	 0xB9, 0xBF, 0xCE, 0xC1, 0x9B, 0xA5, 0x8D, 0xBC, 0xCA, 0xBE,
	 0x00, 0x85, 0x00, 0x83, 0x00, 0x9E},
	/* 80 */
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0xA2, 0xA4, 0x8E, 0xA6, 0xBD,
	 0xB8, 0xC0, 0xCF, 0xC1, 0x9B, 0xA5, 0x8E, 0xBC, 0xC9, 0xBD,
	 0x00, 0x8B, 0x00, 0x88, 0x00, 0xA4},
	/* 90 */
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0xB1, 0xB5, 0x9D, 0xA5, 0xBC,
	 0xB7, 0xC3, 0xD2, 0xC3, 0x9A, 0xA4, 0x8D, 0xBA, 0xC7, 0xBB,
	 0x00, 0x91, 0x00, 0x8D, 0x00, 0xAB},
	/* 100 */
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0xAA, 0xB1, 0x97, 0xA5, 0xBC,
	 0xB7, 0xC3, 0xD1, 0xC2, 0x9B, 0xA5, 0x8F, 0xB9, 0xC6, 0xBB,
	 0x00, 0x96, 0x00, 0x91, 0x00, 0xB0},
	/* 110 */
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0xA5, 0xAC, 0x92, 0xA9, 0xBF,
	 0xBA, 0xC1, 0xCF, 0xC0, 0x9B, 0xA5, 0x90, 0xB7, 0xC4, 0xB9,
	 0x00, 0x9B, 0x00, 0x96, 0x00, 0xB5},
	/* 120 */
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0xAD, 0xB7, 0x9B, 0xAA, 0xC0,
	 0xBA, 0xC2, 0xD0, 0xC1, 0x9A, 0xA4, 0x8F, 0xB8, 0xC4, 0xB9,
	 0x00, 0x9F, 0x00, 0x99, 0x00, 0xBA},
	/* 130 */
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0xA8, 0xB3, 0x96, 0xAE, 0xC3,
	 0xBE, 0xC0, 0xCE, 0xBF, 0x9A, 0xA4, 0x90, 0xB7, 0xC3, 0xB8,
	 0x00, 0xA3, 0x00, 0x9D, 0x00, 0xBF},
	/* 140 */
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0xB0, 0xBD, 0x9E, 0xAF, 0xC4,
	 0xBE, 0xC0, 0xCE, 0xBF, 0x9B, 0xA5, 0x91, 0xB6, 0xC1, 0xB6,
	 0x00, 0xA8, 0x00, 0xA2, 0x00, 0xC4},
	/* 150 */
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0xAC, 0xBA, 0x9A, 0xB1, 0xC6,
	 0xBF, 0xC1, 0xCE, 0xC0, 0x99, 0xA3, 0x8F, 0xB5, 0xC0, 0xB4,
	 0x00, 0xAC, 0x00, 0xA6, 0x00, 0xCA},
	/* 160 */
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0xAC, 0xBA, 0x9A, 0xAE, 0xC3,
	 0xBC, 0xC0, 0xCD, 0xBF, 0x99, 0xA3, 0x90, 0xB3, 0xBE, 0xB1,
	 0x00, 0xB1, 0x00, 0xAA, 0x00, 0xCF},
	/* 170 */
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0xB5, 0xC5, 0xA4, 0xAE, 0xC3,
	 0xBA, 0xC2, 0xCE, 0xC2, 0x98, 0xA3, 0x90, 0xB3, 0xBD, 0xB1,
	 0x00, 0xB5, 0x00, 0xAE, 0x00, 0xD3},
	/* 180 */
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0xB1, 0xC2, 0xA0, 0xB0, 0xC4,
	 0xBC, 0xC1, 0xCD, 0xC0, 0x98, 0xA2, 0x90, 0xB3, 0xBD, 0xB0,
	 0x00, 0xB8, 0x00, 0xB1, 0x00, 0xD8},
	/* 190 */
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0xB1, 0xC2, 0xA0, 0xAD, 0xC2,
	 0xB9, 0xC0, 0xCC, 0xBF, 0x98, 0xA3, 0x90, 0xB2, 0xBB, 0xAF,
	 0x00, 0xBC, 0x00, 0xB5, 0x00, 0xDC},
	/* 200 */
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0xAD, 0xBF, 0x9C, 0xAF, 0xC4,
	 0xBA, 0xC1, 0xCD, 0xC0, 0x97, 0xA2, 0x8F, 0xB1, 0xBA, 0xAD,
	 0x00, 0xC0, 0x00, 0xB8, 0x00, 0xE1},
	/* 210 */
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0xB2, 0xC4, 0xA1, 0xB1, 0xC5,
	 0xBC, 0xC0, 0xCC, 0xBF, 0x97, 0xA2, 0x90, 0xB0, 0xB9, 0xAC,
	 0x00, 0xC3, 0x00, 0xBC, 0x00, 0xE5},
	/* 220 */
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0xB2, 0xC4, 0xA1, 0xAE, 0xC3,
	 0xB9, 0xBF, 0xCB, 0xBE, 0x96, 0xA2, 0x90, 0xB1, 0xB9, 0xAC,
	 0x00, 0xC6, 0x00, 0xBF, 0x00, 0xE9},
	/* 230 */
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0xAE, 0xC1, 0x9D, 0xB0, 0xC5,
	 0xBA, 0xC0, 0xCB, 0xBF, 0x95, 0xA1, 0x8F, 0xB0, 0xB8, 0xAB,
	 0x00, 0xCA, 0x00, 0xC2, 0x00, 0xED},
	/* 240 */
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0xB2, 0xC7, 0xA2, 0xB2, 0xC6,
	 0xBC, 0xC0, 0xCA, 0xBE, 0x96, 0xA1, 0x8F, 0xB0, 0xB7, 0xAB,
	 0x00, 0xCD, 0x00, 0xC5, 0x00, 0xF1},
	/* 250 */
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0xB2, 0xC7, 0xA2, 0xAF, 0xC4,
	 0xB9, 0xC0, 0xCB, 0xBF, 0x95, 0xA1, 0x8F, 0xAE, 0xB5, 0xA8,
	 0x00, 0xD1, 0x00, 0xC8, 0x00, 0xF6},
	/* 260 */
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0xAF, 0xC4, 0x9E, 0xB1, 0xC6,
	 0xBA, 0xC0, 0xCA, 0xBF, 0x96, 0xA1, 0x90, 0xAE, 0xB5, 0xA8,
	 0x00, 0xD4, 0x00, 0xCB, 0x00, 0xF9},
	/* 270 */
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0xAF, 0xC4, 0x9E, 0xAE, 0xC4,
	 0xB7, 0xC1, 0xCA, 0xC0, 0x95, 0xA0, 0x8F, 0xAE, 0xB4, 0xA8,
	 0x00, 0xD7, 0x00, 0xCE, 0x00, 0xFD},
	/* 280 */
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0xB3, 0xCA, 0xA3, 0xB0, 0xC5,
	 0xB9, 0xC1, 0xCB, 0xC0, 0x93, 0x9F, 0x8E, 0xAE, 0xB4, 0xA7,
	 0x00, 0xDA, 0x00, 0xD1, 0x01, 0x00},
	/* 290 */
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0xB3, 0xCA, 0xA3, 0xAE, 0xC3,
	 0xB6, 0xC1, 0xCA, 0xC0, 0x95, 0xA0, 0x8F, 0xAD, 0xB3, 0xA6,
	 0x00, 0xDD, 0x00, 0xD4, 0x01, 0x04},
	/* 300 */
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0xB0, 0xC7, 0xA0, 0xB0, 0xC5,
	 0xB8, 0xC2, 0xCB, 0xC1, 0x94, 0xA0, 0x8F, 0xAD, 0xB3, 0xA6,
	 0x00, 0xE0, 0x00, 0xD7, 0x01, 0x08}
};

static char greenish_gamma_settings_nit[MAX_BL_STEPS][GAMMA_SETTING_SIZE] = {
	/* 10	*/
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0x4C, 0x4C, 0x4C, 0x9B, 0x9B,
	 0x9B, 0xB8, 0xC6, 0xB9, 0x89, 0xA3, 0x8A, 0xC0, 0xCE, 0xC5,
	 0x00, 0x4C, 0x00, 0x4B, 0x00, 0x59},
	/* 20	*/
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0x80, 0x80, 0x80, 0xA7, 0xB1,
	 0xA8, 0xB3, 0xC6, 0xB3, 0x97, 0xAD, 0x9B, 0xBF, 0xC9, 0xBF,
	 0x00, 0x5C, 0x00, 0x5C, 0x00, 0x6C},
	/* 30	*/
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0x71, 0x71, 0x71, 0xA6, 0xB9,
	 0xA7, 0xAF, 0xC2, 0xAF, 0x9E, 0xB2, 0xA3, 0xBC, 0xC5, 0xBA,
	 0x00, 0x68, 0x00, 0x69, 0x00, 0x7A},
	/* 40	*/
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0x8C, 0x8C, 0x8C, 0x99, 0xB1,
	 0x99, 0xB6, 0xC7, 0xB7, 0x9D, 0xB0, 0xA1, 0xBE, 0xC7, 0xBC,
	 0x00, 0x71, 0x00, 0x71, 0x00, 0x84},
	/* 50	*/
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0x96, 0x99, 0x96, 0x9A, 0xB4,
	 0x9B, 0xBD, 0xCC, 0xBF, 0x9C, 0xAD, 0x9F, 0xBC, 0xC5, 0xB9,
	 0x00, 0x79, 0x00, 0x79, 0x00, 0x8E},
	/* 60	*/
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0x8F, 0x94, 0x8F, 0x9A, 0xB3,
	 0x9B, 0xBF, 0xCD, 0xC2, 0x9A, 0xAB, 0x9C, 0xBC, 0xC5, 0xB9,
	 0x00, 0x7F, 0x00, 0x80, 0x00, 0x95},
	/* 70	*/
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0x9E, 0xA6, 0x9E, 0x9A, 0xB2,
	 0x9A, 0xC1, 0xCF, 0xC4, 0x99, 0xA9, 0x9A, 0xBD, 0xC5, 0xB9,
	 0x00, 0x85, 0x00, 0x85, 0x00, 0x9C},
	/* 80	*/
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0x91, 0x9C, 0x91, 0xA2, 0xB7,
	 0xA2, 0xC2, 0xD0, 0xC7, 0x9A, 0xA9, 0x9A, 0xBB, 0xC3, 0xB7,
	 0x00, 0x8A, 0x00, 0x8B, 0x00, 0xA3},
	/* 90	*/
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0x9E, 0xAD, 0x9F, 0xA1, 0xB6,
	 0xA2, 0xC7, 0xD4, 0xCB, 0x99, 0xA8, 0x98, 0xB9, 0xC1, 0xB5,
	 0x00, 0x90, 0x00, 0x90, 0x00, 0xA9},
	/* 100	*/
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0x98, 0xA8, 0x99, 0xA6, 0xBA,
	 0xA7, 0xC4, 0xD2, 0xC9, 0x98, 0xA6, 0x96, 0xB8, 0xC1, 0xB5,
	 0x00, 0x94, 0x00, 0x95, 0x00, 0xAF},
	/* 110	*/
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0xA6, 0xB7, 0xA7, 0xA0, 0xB5,
	 0xA2, 0xC3, 0xD0, 0xC8, 0x99, 0xA6, 0x96, 0xB9, 0xC1, 0xB5,
	 0x00, 0x99, 0x00, 0x9A, 0x00, 0xB4},
	/* 120	*/
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0xA0, 0xB2, 0xA0, 0xA5, 0xB9,
	 0xA7, 0xC1, 0xCF, 0xC6, 0x99, 0xA6, 0x95, 0xB7, 0xBF, 0xB4,
	 0x00, 0x9D, 0x00, 0x9E, 0x00, 0xBA},
	/* 130	*/
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0x9A, 0xAD, 0x9B, 0xA7, 0xBB,
	 0xA9, 0xC2, 0xCF, 0xC7, 0x98, 0xA5, 0x94, 0xB6, 0xBE, 0xB3,
	 0x00, 0xA1, 0x00, 0xA3, 0x00, 0xBF},
	/* 140	*/
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0xA1, 0xB7, 0xA2, 0xAC, 0xBE,
	 0xAE, 0xC1, 0xCE, 0xC5, 0x98, 0xA5, 0x94, 0xB5, 0xBD, 0xB2,
	 0x00, 0xA6, 0x00, 0xA7, 0x00, 0xC4},
	/* 150	*/
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0x9D, 0xB4, 0x9E, 0xAE, 0xC0,
	 0xB1, 0xC0, 0xCC, 0xC3, 0x97, 0xA4, 0x93, 0xB5, 0xBD, 0xB2,
	 0x00, 0xA9, 0x00, 0xAA, 0x00, 0xC8},
	/* 160	*/
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0x9D, 0xB4, 0x9E, 0xA9, 0xBC,
	 0xAC, 0xC1, 0xCD, 0xC4, 0x98, 0xA5, 0x94, 0xB4, 0xBB, 0xB0,
	 0x00, 0xAD, 0x00, 0xAE, 0x00, 0xCD},
	/* 170	*/
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0xA5, 0xBE, 0xA6, 0xAB, 0xBE,
	 0xAF, 0xC0, 0xCC, 0xC2, 0x97, 0xA4, 0x93, 0xB4, 0xBB, 0xB0,
	 0x00, 0xB0, 0x00, 0xB2, 0x00, 0xD1},
	/* 180	*/
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0xA1, 0xBB, 0xA2, 0xAE, 0xC0,
	 0xB2, 0xC1, 0xCC, 0xC3, 0x96, 0xA3, 0x92, 0xB3, 0xBB, 0xAF,
	 0x00, 0xB4, 0x00, 0xB5, 0x00, 0xD5},
	/* 190	*/
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0x9D, 0xB7, 0x9E, 0xB0, 0xC2,
	 0xB4, 0xC0, 0xCB, 0xC1, 0x96, 0xA2, 0x91, 0xB3, 0xBB, 0xAF,
	 0x00, 0xB7, 0x00, 0xB9, 0x00, 0xD9},
	/* 200	*/
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0xA5, 0xC0, 0xA6, 0xAE, 0xC0,
	 0xB2, 0xBE, 0xCA, 0xC0, 0x96, 0xA3, 0x92, 0xB2, 0xBA, 0xAE,
	 0x00, 0xBB, 0x00, 0xBC, 0x00, 0xDD},
	/* 210	*/
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0xA1, 0xBD, 0xA2, 0xB0, 0xC2,
	 0xB4, 0xBF, 0xCA, 0xC0, 0x95, 0xA2, 0x90, 0xB1, 0xB9, 0xAE,
	 0x00, 0xBE, 0x00, 0xC0, 0x00, 0xE2},
	/* 220	*/
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0x9D, 0xB9, 0x9E, 0xB3, 0xC3,
	 0xB7, 0xBE, 0xC9, 0xBE, 0x96, 0xA2, 0x91, 0xB1, 0xB9, 0xAE,
	 0x00, 0xC1, 0x00, 0xC3, 0x00, 0xE5},
	/* 230	*/
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0x9D, 0xB9, 0x9E, 0xB0, 0xC1,
	 0xB5, 0xBF, 0xC9, 0xBF, 0x94, 0xA1, 0x90, 0xB1, 0xB8, 0xAD,
	 0x00, 0xC4, 0x00, 0xC6, 0x00, 0xE9},
	/* 240	*/
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0xA1, 0xBF, 0xA2, 0xB2, 0xC3,
	 0xB7, 0xBE, 0xC8, 0xBD, 0x95, 0xA1, 0x90, 0xB1, 0xB8, 0xAD,
	 0x00, 0xC7, 0x00, 0xC9, 0x00, 0xEC},
	/* 250	*/
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0xA1, 0xBF, 0xA2, 0xB0, 0xC1,
	 0xB5, 0xBE, 0xC9, 0xBE, 0x94, 0xA0, 0x8F, 0xB0, 0xB8, 0xAD,
	 0x00, 0xCA, 0x00, 0xCC, 0x00, 0xF0},
	/* 260	*/
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0x9D, 0xBC, 0x9E, 0xB2, 0xC3,
	 0xB7, 0xBD, 0xC7, 0xBC, 0x95, 0xA1, 0x90, 0xAF, 0xB7, 0xAC,
	 0x00, 0xCD, 0x00, 0xCE, 0x00, 0xF3},
	/* 270	*/
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0x9D, 0xBC, 0x9E, 0xB0, 0xC1,
	 0xB5, 0xBE, 0xC8, 0xBD, 0x94, 0xA0, 0x8F, 0xAF, 0xB6, 0xAB,
	 0x00, 0xD0, 0x00, 0xD2, 0x00, 0xF7},
	/* 280	*/
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0xA1, 0xC1, 0xA2, 0xB2, 0xC3,
	 0xB7, 0xBD, 0xC7, 0xBC, 0x95, 0xA1, 0x90, 0xAF, 0xB6, 0xAB,
	 0x00, 0xD3, 0x00, 0xD5, 0x00, 0xFB},
	/* 290	*/
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0x9E, 0xBE, 0x9F, 0xB4, 0xC5,
	 0xBA, 0xBE, 0xC7, 0xBC, 0x94, 0xA0, 0x8F, 0xAF, 0xB6, 0xAB,
	 0x00, 0xD5, 0x00, 0xD7, 0x00, 0xFE},
	/* 300  */
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0x9E, 0xBE, 0x9F, 0xB2, 0xC3,
	 0xB8, 0xBF, 0xC8, 0xBD, 0x94, 0xA0, 0x8F, 0xAF, 0xB6, 0xAB,
	 0x00, 0xD8, 0x00, 0xDA, 0x01, 0x01}
};

static char pinkish_gamma_settings_nit[MAX_BL_STEPS][GAMMA_SETTING_SIZE] = {
	/* 10	*/
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0x4C, 0x4C, 0x4C, 0x9B, 0x9B,
	 0x9B, 0xB9, 0xC1, 0xB8, 0x8B, 0x9A, 0x8A, 0xC1, 0xD1, 0xC6,
	 0x00, 0x51, 0x00, 0x46, 0x00, 0x5C},
	/* 20	*/
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0x80, 0x80, 0x80, 0xA8, 0xAE,
	 0xA7, 0xB4, 0xBF, 0xB3, 0x98, 0xAB, 0x9C, 0xBC, 0xC8, 0xBC,
	 0x00, 0x64, 0x00, 0x58, 0x00, 0x71},
	/* 30	*/
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0x71, 0x71, 0x71, 0xA8, 0xB2,
	 0xA6, 0xB0, 0xBB, 0xAF, 0x9E, 0xB3, 0xA3, 0xB9, 0xC3, 0xB5,
	 0x00, 0x72, 0x00, 0x65, 0x00, 0x81},
	/* 40	*/
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0x8C, 0x8C, 0x8C, 0x9A, 0xA8,
	 0x99, 0xB7, 0xC1, 0xB7, 0x9C, 0xB1, 0xA0, 0xBC, 0xC5, 0xB8,
	 0x00, 0x7B, 0x00, 0x6D, 0x00, 0x8B},
	/* 50	*/
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0x96, 0x98, 0x96, 0x9C, 0xAA,
	 0x9A, 0xBE, 0xC9, 0xBF, 0x9A, 0xAD, 0x9C, 0xBA, 0xC4, 0xB7,
	 0x00, 0x85, 0x00, 0x75, 0x00, 0x96},
	/* 60	*/
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0x8F, 0x92, 0x8F, 0x9B, 0xA9,
	 0x9A, 0xC0, 0xCC, 0xC2, 0x98, 0xAA, 0x98, 0xBB, 0xC4, 0xB7,
	 0x00, 0x8B, 0x00, 0x7B, 0x00, 0x9E},
	/* 70	*/
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0x9F, 0xA3, 0x9E, 0x9B, 0xA9,
	 0x9A, 0xC2, 0xCF, 0xC5, 0x96, 0xA8, 0x96, 0xBB, 0xC5, 0xB8,
	 0x00, 0x92, 0x00, 0x81, 0x00, 0xA5},
	/* 80	*/
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0x92, 0x98, 0x91, 0xA3, 0xAF,
	 0xA2, 0xC3, 0xD1, 0xC7, 0x97, 0xA8, 0x95, 0xB9, 0xC3, 0xB6,
	 0x00, 0x98, 0x00, 0x86, 0x00, 0xAC},
	/* 90	*/
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0x9F, 0xA7, 0x9E, 0xA3, 0xAE,
	 0xA1, 0xC7, 0xD6, 0xCC, 0x95, 0xA6, 0x93, 0xB8, 0xC1, 0xB4,
	 0x00, 0x9E, 0x00, 0x8C, 0x00, 0xB3},
	/* 100  */
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0x99, 0xA2, 0x98, 0xA7, 0xB3,
	 0xA7, 0xC5, 0xD4, 0xCA, 0x94, 0xA4, 0x91, 0xB7, 0xC0, 0xB3,
	 0x00, 0xA3, 0x00, 0x91, 0x00, 0xB9},
	/* 110  */
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0xA7, 0xB1, 0xA6, 0xA2, 0xAF,
	 0xA1, 0xC4, 0xD3, 0xC9, 0x95, 0xA4, 0x91, 0xB7, 0xC0, 0xB4,
	 0x00, 0xA8, 0x00, 0x95, 0x00, 0xBF},
	/* 120  */
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0xA1, 0xAC, 0xA0, 0xA6, 0xB3,
	 0xA7, 0xC2, 0xD1, 0xC7, 0x94, 0xA3, 0x90, 0xB6, 0xBE, 0xB2,
	 0x00, 0xAD, 0x00, 0x9A, 0x00, 0xC5},
	/* 130  */
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0x9B, 0xA6, 0x9A, 0xA8, 0xB6,
	 0xA9, 0xC3, 0xD2, 0xC7, 0x94, 0xA3, 0x8F, 0xB5, 0xBE, 0xB2,
	 0x00, 0xB1, 0x00, 0x9E, 0x00, 0xCA},
	/* 140  */
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0xA3, 0xAF, 0xA1, 0xAD, 0xBA,
	 0xAE, 0xC1, 0xD0, 0xC5, 0x94, 0xA2, 0x8F, 0xB4, 0xBD, 0xB1,
	 0x00, 0xB6, 0x00, 0xA2, 0x00, 0xCF},
	/* 150  */
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0x9F, 0xAB, 0x9D, 0xAF, 0xBD,
	 0xB1, 0xBF, 0xCE, 0xC3, 0x94, 0xA2, 0x8F, 0xB4, 0xBD, 0xB1,
	 0x00, 0xBA, 0x00, 0xA5, 0x00, 0xD3},
	/* 160  */
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0x9F, 0xAB, 0x9D, 0xAA, 0xB9,
	 0xAC, 0xC1, 0xCE, 0xC3, 0x94, 0xA2, 0x8F, 0xB3, 0xBC, 0xB0,
	 0x00, 0xBE, 0x00, 0xA9, 0x00, 0xD9},
	/* 170  */
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0xA7, 0xB5, 0xA5, 0xAD, 0xBC,
	 0xAF, 0xBF, 0xCC, 0xC1, 0x94, 0xA2, 0x8F, 0xB3, 0xBC, 0xB0,
	 0x00, 0xC2, 0x00, 0xAC, 0x00, 0xDD},
	/* 180  */
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0xA3, 0xB1, 0xA1, 0xAF, 0xBE,
	 0xB2, 0xC0, 0xCD, 0xC1, 0x93, 0xA1, 0x8E, 0xB2, 0xBC, 0xAF,
	 0x00, 0xC6, 0x00, 0xAF, 0x00, 0xE1},
	/* 190  */
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0x9F, 0xAE, 0x9D, 0xB2, 0xC1,
	 0xB5, 0xBE, 0xCB, 0xBF, 0x93, 0xA0, 0x8E, 0xB2, 0xBC, 0xB0,
	 0x00, 0xC9, 0x00, 0xB2, 0x00, 0xE5},
	/* 200  */
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0xA7, 0xB6, 0xA5, 0xAF, 0xBF,
	 0xB2, 0xBD, 0xC9, 0xBD, 0x93, 0xA1, 0x8E, 0xB2, 0xBB, 0xAF,
	 0x00, 0xCD, 0x00, 0xB5, 0x00, 0xEA},
	/* 210  */
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0xA3, 0xB3, 0xA1, 0xB1, 0xC1,
	 0xB5, 0xBD, 0xC9, 0xBD, 0x92, 0xA0, 0x8D, 0xB1, 0xBA, 0xAE,
	 0x00, 0xD1, 0x00, 0xB9, 0x00, 0xEE},
	/* 220  */
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0x9F, 0xAF, 0x9D, 0xB4, 0xC4,
	 0xB8, 0xBC, 0xC8, 0xBB, 0x93, 0xA0, 0x8E, 0xB1, 0xBB, 0xAE,
	 0x00, 0xD4, 0x00, 0xBB, 0x00, 0xF1},
	/* 230  */
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0x9F, 0xAF, 0x9D, 0xB1, 0xC2,
	 0xB5, 0xBC, 0xC8, 0xBC, 0x92, 0x9F, 0x8D, 0xB0, 0xBA, 0xAE,
	 0x00, 0xD8, 0x00, 0xBE, 0x00, 0xF6},
	/* 240  */
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0xA3, 0xB4, 0xA1, 0xB3, 0xC4,
	 0xB8, 0xBB, 0xC7, 0xBA, 0x92, 0xA0, 0x8D, 0xB0, 0xBA, 0xAE,
	 0x00, 0xDB, 0x00, 0xC1, 0x00, 0xF9},
	/* 250  */
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0xA3, 0xB4, 0xA1, 0xB1, 0xC2,
	 0xB5, 0xBB, 0xC7, 0xBA, 0x91, 0x9F, 0x8C, 0xB0, 0xBA, 0xAE,
	 0x00, 0xDE, 0x00, 0xC4, 0x00, 0xFC},
	/* 260  */
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0x9F, 0xB0, 0x9D, 0xB3, 0xC5,
	 0xB8, 0xBA, 0xC5, 0xB8, 0x93, 0xA0, 0x8E, 0xAF, 0xB9, 0xAD,
	 0x00, 0xE1, 0x00, 0xC6, 0x01, 0x00},
	/* 270  */
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0x9F, 0xB0, 0x9D, 0xB1, 0xC3,
	 0xB6, 0xBB, 0xC5, 0xB9, 0x92, 0x9F, 0x8D, 0xAF, 0xB9, 0xAC,
	 0x00, 0xE4, 0x00, 0xC9, 0x01, 0x04},
	/* 280  */
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0xA3, 0xB5, 0xA1, 0xB3, 0xC5,
	 0xB8, 0xB9, 0xC4, 0xB7, 0x93, 0xA0, 0x8E, 0xAF, 0xB9, 0xAD,
	 0x00, 0xE7, 0x00, 0xCC, 0x01, 0x08},
	/* 290  */
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0xA0, 0xB2, 0x9E, 0xB5, 0xC7,
	 0xBB, 0xBA, 0xC4, 0xB7, 0x92, 0x9F, 0x8D, 0xAF, 0xB9, 0xAD,
	 0x00, 0xEA, 0x00, 0xCF, 0x01, 0x0B},
	/* 300  */
	{0xFA, 0x02, 0x51, 0x39, 0x55, 0xA0, 0xB2, 0x9E, 0xB3, 0xC6,
	 0xB9, 0xBB, 0xC5, 0xB8, 0x92, 0x9F, 0x8D, 0xAF, 0xB9, 0xAD,
	 0x00, 0xED, 0x00, 0xD1, 0x01, 0x0E}
};

static int smd_qhd_amoled_cmd_set_brightness(
	struct mdfld_dsi_config *dsi_config,
	int level);

static struct board_power_props smi_p1_board = {
	.reset_gpio = 96 + 32, /* GPIO_CORE_32 */
	.num_voltage_reg = 2,
	.reg = {
		/* VDDIO */
		[0] = {
			.gpio = 96 + 75, /* GPIO_CORE_75 */
			.gpio_en_val = 1,
		},
		/* VBATT */
		[1] = {
			.gpio = 78, /* GPIO_AON_78 */
			.gpio_en_val = 1,
		}
	}
};

static struct panel_power_props smd_qhd_amoled_cmd_power_props = {
	.reset_gpio_en_val = 0,
	.reset_post_delay = 15,
	.reg_apply_post_delay = 30,
	.board = &smi_p1_board, /* TODO: Do dynamic based on board type */
};

int smd_qhd_amoled_cmd_acl_update(struct mdfld_dsi_config *dsi_config)
{
	int err;
	struct mdfld_dsi_pkg_sender *sender =
		mdfld_dsi_get_pkg_sender(dsi_config);
	int data = ((mdfld_mot_cmn_acl_mode_get() == 1) ? 1 : 0);
	err = mdfld_dsi_send_mcs_short_hs(sender, 0xc0, data, 1,
					MDFLD_DSI_SEND_PACKAGE);
	if (err)
		DRM_ERROR("Failed to set panel to ACL mode %d\n", data);
	else
		PSB_DEBUG_ENTRY("Panel ACL mode set to %d\n", data);

	return err;
}

static void smd_qhd_amoled_cmd_dsi_cntrl_init(
	struct mdfld_dsi_config *dsi_config,
	int pipe, int update)
{
	struct mdfld_dsi_hw_context *hw_ctx =
		&dsi_config->dsi_hw_context;
	struct drm_device *dev = dsi_config->dev;
	struct drm_psb_private *dev_priv =
		(struct drm_psb_private *)dev->dev_private;
	struct mdfld_dsi_hw_registers *regs = &dsi_config->regs;
	int lane_count = dsi_config->lane_count;
	struct mdfld_dsi_pkg_sender *sender =
		mdfld_dsi_get_pkg_sender(dsi_config);

	PSB_DEBUG_ENTRY("%s: initializing dsi controller on pipe %d"
			" for AMOLED command\n", __func__, pipe);

	hw_ctx->mipi_control = 0x18;
	hw_ctx->intr_en = 0xffffffff;
	hw_ctx->hs_tx_timeout = 0xffffff;
	hw_ctx->lp_rx_timeout = 0xffffff;
	hw_ctx->turn_around_timeout = 0x14;
	hw_ctx->device_reset_timer = 0xffff;
	hw_ctx->high_low_switch_count = 0x18;
	hw_ctx->init_count = 0xf0;
	hw_ctx->eot_disable = 0x3a;
	hw_ctx->lp_byteclk = 0x6;
	hw_ctx->clk_lane_switch_time_cnt = 0x18000b;
	hw_ctx->dphy_param = 0x160d3610;
	hw_ctx->dbi_bw_ctrl = 0x820;
	if (dev_priv->platform_rev_id == MDFLD_PNW_A0)
		hw_ctx->mipi = PASS_FROM_SPHY_TO_AFE | SEL_FLOPPED_HSTX;
	else
		hw_ctx->mipi = PASS_FROM_SPHY_TO_AFE;

	/* Turn on HW TE and TE delay */
	hw_ctx->mipi |= TE_TRIGGER_GPIO_PIN | TE_USE_COUNTER_DELAY;
	hw_ctx->te_delay = 0xffff;

	/*set up func_prg*/
	hw_ctx->dsi_func_prg = (0xa000 | lane_count);

	REG_WRITE(regs->mipi_reg, hw_ctx->mipi);
	REG_WRITE(regs->te_delay_reg, hw_ctx->te_delay);

	if (update) {
		/* D-PHY parameter */
		REG_WRITE(regs->dphy_param_reg, hw_ctx->dphy_param);

		/* Configure DSI controller */
		REG_WRITE(regs->mipi_control_reg, hw_ctx->mipi_control);
		REG_WRITE(regs->intr_en_reg, hw_ctx->intr_en);
		REG_WRITE(regs->hs_tx_timeout_reg, hw_ctx->hs_tx_timeout);
		REG_WRITE(regs->lp_rx_timeout_reg, hw_ctx->lp_rx_timeout);
		REG_WRITE(regs->turn_around_timeout_reg,
				hw_ctx->turn_around_timeout);
		REG_WRITE(regs->device_reset_timer_reg,
				hw_ctx->device_reset_timer);
		REG_WRITE(regs->high_low_switch_count_reg,
				hw_ctx->high_low_switch_count);
		REG_WRITE(regs->init_count_reg, hw_ctx->init_count);
		REG_WRITE(regs->eot_disable_reg, hw_ctx->eot_disable);
		REG_WRITE(regs->lp_byteclk_reg, hw_ctx->lp_byteclk);
		REG_WRITE(regs->dbi_bw_ctrl_reg, hw_ctx->dbi_bw_ctrl);
		REG_WRITE(regs->clk_lane_switch_time_cnt_reg,
				hw_ctx->clk_lane_switch_time_cnt);
		REG_WRITE(regs->dsi_func_prg_reg, hw_ctx->dsi_func_prg);

		/* Enable DSI Controller */
		REG_WRITE(regs->device_ready_reg, BIT0);
	}

	mdfld_dsi_pkg_sender_set_cmd_packet_delay(sender, 50);
}

static struct drm_display_mode *smd_qhd_amoled_cmd_get_config_mode(
	struct drm_device *dev)
{
	struct drm_display_mode *mode;
	struct drm_psb_private *dev_priv =
		(struct drm_psb_private *)dev->dev_private;
	struct mrst_timing_info *ti = &dev_priv->gct_data.DTD;
	bool use_gct = false;

	PSB_DEBUG_ENTRY("\n");

	mode = kzalloc(sizeof(*mode), GFP_KERNEL);
	if (!mode)
		return NULL;

	if (use_gct) {
		PSB_DEBUG_ENTRY("gct find MIPI panel.\n");

		mode->hdisplay = (ti->hactive_hi << 8) | ti->hactive_lo;
		mode->vdisplay = (ti->vactive_hi << 8) | ti->vactive_lo;
		mode->hsync_start = mode->hdisplay + \
				((ti->hsync_offset_hi << 8) | \
				ti->hsync_offset_lo);
		mode->hsync_end = mode->hsync_start + \
				((ti->hsync_pulse_width_hi << 8) | \
				ti->hsync_pulse_width_lo);
		mode->htotal = mode->hdisplay + ((ti->hblank_hi << 8) | \
								ti->hblank_lo);
		mode->vsync_start = \
			mode->vdisplay + ((ti->vsync_offset_hi << 8) | \
						ti->vsync_offset_lo);
		mode->vsync_end = \
			mode->vsync_start + ((ti->vsync_pulse_width_hi << 8) | \
						ti->vsync_pulse_width_lo);
		mode->vtotal = mode->vdisplay + \
				((ti->vblank_hi << 8) | ti->vblank_lo);
		mode->clock = ti->pixel_clock * 10;

		PSB_DEBUG_ENTRY("hdisplay is %d\n", mode->hdisplay);
		PSB_DEBUG_ENTRY("vdisplay is %d\n", mode->vdisplay);
		PSB_DEBUG_ENTRY("HSS is %d\n", mode->hsync_start);
		PSB_DEBUG_ENTRY("HSE is %d\n", mode->hsync_end);
		PSB_DEBUG_ENTRY("htotal is %d\n", mode->htotal);
		PSB_DEBUG_ENTRY("VSS is %d\n", mode->vsync_start);
		PSB_DEBUG_ENTRY("VSE is %d\n", mode->vsync_end);
		PSB_DEBUG_ENTRY("vtotal is %d\n", mode->vtotal);
		PSB_DEBUG_ENTRY("clock is %d\n", mode->clock);
	} else {
		mode->hdisplay = 540;
		mode->vdisplay = 960;

		/* TODO: Why are there front/back porch settings */

		/* HFP = 40, HSYNC = 10, HBP = 20 */
		mode->hsync_start = mode->hdisplay + 40;
		mode->hsync_end = mode->hsync_start + 10;
		mode->htotal = mode->hsync_end + 20;
		/* VFP = 4, VSYNC = 2, VBP = 4 */
		mode->vsync_start = mode->vdisplay + 4;
		mode->vsync_end = mode->vsync_start + 2;
		mode->vtotal = mode->vsync_end + 4;

		/* Currently, 60 = 213MHz, 65 = 230 MHz */
		mode->vrefresh = 65;
		mode->clock = mode->vrefresh * (mode->vtotal + 1) *
			(mode->htotal + 1) / 1000;
	}

	drm_mode_set_name(mode);
	drm_mode_set_crtcinfo(mode, 0);

	mode->type |= DRM_MODE_TYPE_PREFERRED;

	return mode;
}

static bool smd_qhd_amoled_cmd_dsi_dbi_mode_fixup(struct drm_encoder *encoder,
				     struct drm_display_mode *mode,
				     struct drm_display_mode *adjusted_mode)
{
	struct drm_device *dev = encoder->dev;

	/* TODO: Cleanup to make generic? */
	struct drm_display_mode *fixed_mode =
		smd_qhd_amoled_cmd_get_config_mode(dev);

	PSB_DEBUG_ENTRY("\n");

	if (fixed_mode) {
		adjusted_mode->hdisplay = fixed_mode->hdisplay;
		adjusted_mode->hsync_start = fixed_mode->hsync_start;
		adjusted_mode->hsync_end = fixed_mode->hsync_end;
		adjusted_mode->htotal = fixed_mode->htotal;
		adjusted_mode->vdisplay = fixed_mode->vdisplay;
		adjusted_mode->vsync_start = fixed_mode->vsync_start;
		adjusted_mode->vsync_end = fixed_mode->vsync_end;
		adjusted_mode->vtotal = fixed_mode->vtotal;
		adjusted_mode->clock = fixed_mode->clock;
		drm_mode_set_crtcinfo(adjusted_mode, CRTC_INTERLACE_HALVE_V);
		kfree(fixed_mode);
	}

	return true;
}

static int smd_qhd_amoled_cmd_bl_power_on(struct mdfld_dsi_config *dsi_config)
{
	int level;
	struct backlight_device *psb_bl = psb_get_backlight_device();

	if (!psb_bl)
		level = BRIGHTNESS_MAX_LEVEL;
	else
		level = psb_bl->props.brightness;

	return smd_qhd_amoled_cmd_set_brightness(dsi_config, level);
}

static void smd_qhd_amoled_cmd_get_mtp_set4(struct mdfld_dsi_config *dsi_config,
					u8 *elvss, u8 *white_pt_adj)
{
	static bool is_cached;
	static u8 cached_elvss = 0x08; /* init to default value per spec */
	static u8 cached_white_pt_adj = 0xff;
	struct mdfld_dsi_pkg_sender *sender =
		mdfld_dsi_get_pkg_sender(dsi_config);
	int r = 0;
	u32 reg_data;
	u8 ver;

	if (!is_cached) {
		r = mdfld_dsi_read_mcs_hs(sender, 0xd4, &reg_data, 1);
		if (r != 1) {
			DRM_ERROR("Failed to read MTP_SET4, r = %d\n", r);
		} else {
			cached_elvss = reg_data & 0x3f;
			if (mdfld_mot_cmn_get_panel_cntrl_ver(sender, &ver))
				DRM_ERROR("Failed to get panel controller "
					"version\n");
			else {
				if (ver >= 1)
					cached_white_pt_adj =
						(reg_data & 0xf000) >> 12;

				printk(KERN_ALERT"Read MTP_SET4, elvss = 0x%02x,"
					"white_pt = 0x%02x\n",
					cached_elvss, cached_white_pt_adj);
				is_cached = true;
			}
		}
	}

	if (elvss)
		*elvss = cached_elvss;

	if (white_pt_adj)
		*white_pt_adj = cached_white_pt_adj;
}

static int __smd_qhd_amoled_cmd_dsi_power_on(
	struct mdfld_dsi_config *dsi_config)
{
	struct drm_device *dev = dsi_config->dev;
	struct mdfld_dsi_pkg_sender *sender =
		mdfld_dsi_get_pkg_sender(dsi_config);
	u8 etc_cond2_cmd_13[]  = { 0xB2, 0x00, 0x00, 0x00, 0x00 };
	u8 elvss;
	u8 ver;
	u8 cmd = 0;
	int err = 0;
	int retry;

	PSB_DEBUG_ENTRY("Start AMOLED command mode init sequence\n");

	if (!sender) {
		DRM_ERROR("Failed to get DSI packet sender\n");
		return -EINVAL;
	}

	err = mdfld_mot_cmd_mot_panel_power_apply(
		&smd_qhd_amoled_cmd_power_props);
	if (err)
		return err;

	/* TODO: Read panel id info, but do nothing with it for now */
	mdfld_mot_cmn_get_panel_manufacture(sender, &ver);
	mdfld_mot_cmn_get_panel_cntrl_ver(sender, &ver);
	mdfld_mot_cmn_get_panel_cntrl_drv_ver(sender, &ver);

	err = mdfld_mot_cmn_send_cmd_list(dsi_config, sender,
					init_seq_1,
					ARRAY_SIZE(init_seq_1));
	if (err)
		return err;

	err = smd_qhd_amoled_cmd_bl_power_on(dsi_config);
	if (err)
		return err;


	err = mdfld_mot_cmn_send_cmd_list(dsi_config, sender,
					init_seq_2,
					ARRAY_SIZE(init_seq_2));
	if (err)
		return err;


	smd_qhd_amoled_cmd_get_mtp_set4(dsi_config, &elvss, NULL);
	if (mdfld_mot_cmn_elvss_tth_state_get() == 1)
		elvss += 0xf;

	etc_cond2_cmd_13[1] = elvss;
	etc_cond2_cmd_13[2] = elvss;
	etc_cond2_cmd_13[3] = elvss;
	etc_cond2_cmd_13[4] = elvss;
	err = mdfld_dsi_send_mcs_long_hs(sender, etc_cond2_cmd_13,
					sizeof(etc_cond2_cmd_13),
					MDFLD_DSI_SEND_PACKAGE);
	if (err)
		return err;

	err = mdfld_mot_cmn_send_cmd_list(dsi_config, sender,
					init_seq_3,
					ARRAY_SIZE(init_seq_3));
	if (err)
		return err;

	err = smd_qhd_amoled_cmd_acl_update(dsi_config);
	if (err)
		return err;

	/* Ensure counters do not match to prevent detection of
	   duplicate frame */
	atomic64_set(&sender->last_screen_update,
		(atomic64_read(&sender->te_seq) - 1));

	cmd = write_mem_start;
	err = mdfld_dsi_send_dcs(sender,
			cmd,
			NULL,
			0,
			CMD_DATA_SRC_PIPE,
			MDFLD_DSI_SEND_PACKAGE);
	if (err) {
		DRM_ERROR("DCS 0x%x sent failed\n", cmd);
		return err;
	}

	/* Ensure frame is sent out before turning on display */
	retry = 20;
	while (retry) {
		if (!(REG_READ(sender->mipi_gen_fifo_stat_reg) & BIT27))
			break;
		else {
			usleep_range(1000, 1100);
			retry--;
		}
	}

	cmd = set_display_on;
	err = mdfld_dsi_send_dcs(sender,
			cmd,
			NULL,
			0,
			CMD_DATA_SRC_SYSTEM_MEM,
			MDFLD_DSI_SEND_PACKAGE);
	if (err) {
		DRM_ERROR("DCS 0x%x sent failed\n", cmd);
		return err;
	}

	printk(KERN_INFO"Panel is on\n");

	return err;
}

static int __smd_qhd_amoled_cmd_dsi_power_off(
	struct mdfld_dsi_config *dsi_config)
{
	struct mdfld_dsi_pkg_sender *sender =
		mdfld_dsi_get_pkg_sender(dsi_config);
	u8 cmd = 0;
	int err = 0;

	PSB_DEBUG_ENTRY("Turn off AMOLED command mode panel...\n");

	if (!sender) {
		DRM_ERROR("Failed to get DSI packet sender\n");
		return -EINVAL;
	}

	/*set display off*/
	cmd = set_display_off;
	err = mdfld_dsi_send_dcs(sender,
			cmd,
			NULL,
			0,
			CMD_DATA_SRC_SYSTEM_MEM,
			MDFLD_DSI_SEND_PACKAGE);
	if (err) {
		DRM_ERROR("DCS 0x%x sent failed\n", cmd);
		return err;
	}

	/*enter sleep mode*/
	cmd = enter_sleep_mode;
	err = mdfld_dsi_send_dcs(sender,
			cmd,
			NULL,
			0,
			CMD_DATA_SRC_SYSTEM_MEM,
			MDFLD_DSI_SEND_PACKAGE);
	if (err) {
		DRM_ERROR("DCS 0x%x sent failed\n", cmd);
		return err;
	}

	msleep(120);

	err = mdfld_mot_cmd_mot_panel_power_remove(
		&smd_qhd_amoled_cmd_power_props);

	printk(KERN_INFO"Panel is off\n");

	return err;
}

void smd_qhd_amoled_cmd_dsi_dbi_restore(struct drm_encoder *encoder)
{
	struct mdfld_dsi_encoder *dsi_encoder = NULL;
	struct mdfld_dsi_config *dsi_config = NULL;
	struct drm_device *dev = encoder->dev;
	struct drm_psb_private *dev_priv = dev->dev_private;

	if (!encoder)
		return;

	if (!dev_priv->dsi_init_done)
		return;

	dsi_encoder = MDFLD_DSI_ENCODER(encoder);
	dsi_config = mdfld_dsi_encoder_get_config(dsi_encoder);

	/* TODO: Change this to make common? */
	smd_qhd_amoled_cmd_dsi_cntrl_init(dsi_config, dsi_config->pipe, true);

	/*turn on*/
	mdfld_panel_generic_dsi_dbi_set_power(encoder, true);
}

static int __smd_qhd_amoled_cmd_reboot_notifier(struct notifier_block *nb,
			unsigned long val, void *v)
{
	char *cmd = (char *) v;
	int ret = NOTIFY_DONE;
	struct drm_psb_private *dev_priv = container_of(nb,
						struct drm_psb_private,
						dbi_panel_reboot_notifier);

	if (!dev_priv->dsi_init_done)
		goto end;

	/* If kexec happening, do not turn off to allow smooth BOS -> AOS
	   display transition */
	if (kexec_in_progress)
		goto end;

	mdfld_panel_generic_dsi_dbi_set_power(&dev_priv->encoder0->base, false);

end:
	return ret;
}


static int smd_qhd_amoled_cmd_get_panel_info(struct drm_device *dev,
		int pipe, struct panel_info *pi)
{
	if (!dev || !pi)
		return -EINVAL;

	/* TODO: Change this to make common? */
	pi->width_mm = 53;
	pi->height_mm = 95;

	return 0;
}

static int smd_qhd_amoled_cmd_dsi_detect(struct mdfld_dsi_config *dsi_config,
		int pipe)
{
	int status;

	PSB_DEBUG_ENTRY("Detecting panel %d connection status....\n", pipe);

	if (pipe == 0) {
		/* reconfig lane configuration */
		dsi_config->lane_count = 2;
		dsi_config->lane_config = MDFLD_DSI_DATA_LANE_2_2;
		dsi_config->dsi_hw_context.pll_bypass_mode = 0;

		/* This is for 400 mhz. Set it to 0 for 800mhz */
		dsi_config->dsi_hw_context.cck_div = 1;
		status = MDFLD_DSI_PANEL_CONNECTED;
	} else {
		PSB_DEBUG_ENTRY("Only support single panel\n");
		status = MDFLD_DSI_PANEL_DISCONNECTED;
	}

	return 0;
}

static char *smd_qhd_amoled_cmd_get_gamma_settings(
	struct mdfld_dsi_config *dsi_config,
	int level)
{
	int index;
	char *settings;
	u8 white_pt;

	smd_qhd_amoled_cmd_get_mtp_set4(dsi_config, NULL, &white_pt);

	index = (level * MAX_BL_STEPS) / BRIGHTNESS_MAX_LEVEL;
	if (index < 0)
		index = 0;
	else if (index >= MAX_BL_STEPS)
		index = MAX_BL_STEPS - 1;

	PSB_DEBUG_ENTRY("Set AMOLED brightness level %d (index %d)\n",
			level, index);

	switch (white_pt) {
	case 6:
	case 8:
	case 9:
		settings = greenish_gamma_settings_nit[index];
		break;

	case 1:
	case 2:
	case 4:
		settings = pinkish_gamma_settings_nit[index];
		break;

	default:
		settings = def_gamma_settings_nit[index];
		break;
	}

	return settings;

}

static int smd_qhd_amoled_cmd_set_brightness(
	struct mdfld_dsi_config *dsi_config, int level)
{
	struct mdfld_dsi_pkg_sender *sender =
		mdfld_dsi_get_pkg_sender(dsi_config);
	char *gamma_settings;
	int err;

	if (!sender) {
		DRM_ERROR("Failed to get DSI packet sender\n");
		return -EINVAL;
	}

	gamma_settings = smd_qhd_amoled_cmd_get_gamma_settings(dsi_config,
							level);

	err = mdfld_dsi_send_mcs_long_hs(sender, gamma_settings,
					GAMMA_SETTING_SIZE,
					MDFLD_DSI_SEND_PACKAGE);

	if (err) {
		DRM_ERROR("Failed to send gamma values\n");
		goto func_exit;
	}

	err = mdfld_dsi_send_mcs_short_hs(sender, 0xfa, 0x03, 1,
					MDFLD_DSI_SEND_PACKAGE);
	if (err)
		DRM_ERROR("Failed to set gamma\n");

func_exit:
	return err;
}

static bool smd_qhd_amoled_cmd_esd_detection(
	struct mdfld_dsi_config *dsi_config)
{
	int ret;
	u32 data = 0;

	ret = mdfld_dsi_get_power_mode(dsi_config,
				&data,
				MDFLD_DSI_HS_TRANSMISSION);
	if ((ret != 1) ||
		((ret == 1) && ((data & 0x9C) != 0x9C)))
		return true;

	return false;
}

static void smd_qhd_amoled_cmd_get_reset_delay_time(
	int *pdelay_between_dispaly_island_off_on,
	int *pdelay_after_reset_gpio_toggle)
{
	*pdelay_between_dispaly_island_off_on = 20;
	*pdelay_after_reset_gpio_toggle = 20;
}

/* SMD AMOLED DBI encoder helper funcs */
static const struct drm_encoder_helper_funcs amoled_dsi_dbi_helper_funcs = {
	.save = mdfld_panel_generic_dsi_dbi_save,
	.restore = smd_qhd_amoled_cmd_dsi_dbi_restore,
	.dpms = mdfld_panel_generic_dsi_dbi_dpms,
	.mode_fixup = smd_qhd_amoled_cmd_dsi_dbi_mode_fixup,
	.prepare = mdfld_panel_generic_dsi_dbi_prepare,
	.mode_set = mdfld_panel_generic_dsi_dbi_mode_set,
	.commit = mdfld_panel_generic_dsi_dbi_commit,
};

/* SMD AMOLED DBI encoder funcs */
static const struct drm_encoder_funcs amoled_dsi_dbi_encoder_funcs = {
	.destroy = drm_encoder_cleanup,
};

static struct mdfld_mot_cmn_mot_panel_config amoled_dsi_dbi_mot_panel_config = {
	.acl_update = smd_qhd_amoled_cmd_acl_update,
	.acl_init_state = 0,
	.elvss_tth_supported = true,
};

void smd_qhd_amoled_430_cmd_init(struct drm_device *dev,
				struct panel_funcs *p_funcs)
{

	PSB_DEBUG_ENTRY("\n");

	p_funcs->encoder_funcs = &amoled_dsi_dbi_encoder_funcs;
	p_funcs->encoder_helper_funcs = &amoled_dsi_dbi_helper_funcs;
	p_funcs->get_config_mode = &smd_qhd_amoled_cmd_get_config_mode;
	p_funcs->update_fb = mdfld_panel_generic_dsi_dbi_update_fb;
	p_funcs->get_panel_info = smd_qhd_amoled_cmd_get_panel_info;
	p_funcs->reset = NULL;
	p_funcs->drv_ic_init = NULL;
	p_funcs->dsi_controller_init = smd_qhd_amoled_cmd_dsi_cntrl_init;
	p_funcs->detect = smd_qhd_amoled_cmd_dsi_detect;
	p_funcs->set_brightness = smd_qhd_amoled_cmd_set_brightness;
	p_funcs->power_on = __smd_qhd_amoled_cmd_dsi_power_on;
	p_funcs->power_off = __smd_qhd_amoled_cmd_dsi_power_off;
	p_funcs->disp_control_init = NULL;
	/* Disable ESD detection if using a factory cable */
	if (boot_mode_is_factory())
		p_funcs->esd_detection = NULL;
	else
		p_funcs->esd_detection = smd_qhd_amoled_cmd_esd_detection;

	p_funcs->get_reset_delay_time = smd_qhd_amoled_cmd_get_reset_delay_time;
	p_funcs->mot_panel = &amoled_dsi_dbi_mot_panel_config;
	p_funcs->reboot_notifier = __smd_qhd_amoled_cmd_reboot_notifier;
}
